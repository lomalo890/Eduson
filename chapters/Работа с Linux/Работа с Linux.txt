семафор и мьютекс -- примитивы синхронизации
Два типа ядер:
    монолитные ядра - все компоненты ядра являются одним целым. Быстрые, но более уязвимые
    микроядра -- ядро содержит небольшой набор инструкций, который взаимодействую между собой. При падении одного процесса, есть другой

Линукс -- это юникс-подобная ОС на базе ядра Линукс , которые включают наборы утилит проекта ГНУ.
ГНУ -- это проект по разработке свободного ПО
У андройда нет гнушного набора утилит.

Линукс состоит из 6 компонентов:
Ядро или кернел
загрузчик или бут лодер
утилиты, гни-утилс, утил-линукс
системные библиотеки
файловые системные
средства сборки

Стади включаения:
Инициализация АО через биос
загрузка в ОС
загрузка ядра
самоинициализация ядра

загрузчики:
граб
лило




cat -- вывести содержимое файла
Мы можем указать полный путь к этой утилите (usr/bin/cat)
Откуда линукс знает о том, что это одна и та же утилита?
Все пути к утилитам прописаны в баше: printenv их выведет
Там есть переменная PATH и мы её можем вывести с помощью команды echo $PATH
А чтобы найти утилитку cat? witch cat (usr/bin/cat)
А если надо посмотреть процесс вызова? strace cat hello.txt. Не очень приятный вывод нужно потом читать.
Ну хорошо. А если мы написали какой-то скрипт и хотим, чтобы этот скрипт выполнялся в терминале, но он не выполнится, потому что в переменной PATH нету пути к этому скрипту.
Что делать? Очень просто:
PATH="$PATH:/usr/local/go/bin/"


RedHat платный дистрибутив

ls --посмотреть все папки и файлы из текущей директории
ps -- посмотреть все запущенные процессы
cat > mytext.txt -- записать текст в файл
uname  = отображает название ОС

ГитБаш состоит из файлов exe, потому его можно запустить и в винде
MobaXterm более расширеный терминал gitbash
pwd -- показывает путь к директории
ВСЛ -- подсистема линукс под виндоус

Для винды:

wsl -l -- показывет уже установленные дистрибутивы
wsl -- проникновение в терминал по умолчанию













Контейнеризайия

Одна из разновидностей виртуализации
Аппаратная виртуализация слишком жадная, чем докер, поскольку задействует память и аппаратные ресурсы. В случае контейнеризации изолируется только пространство процессов.
Ядро ОС не изменяется

Единица распространения в докере являыется образ
Образ загружен, после запуска образа создаётся контейнер.

Как с докеро работать?

docker -i -t ubuntu -- -i ГОВОРИМ, ЧТОБЫ ОН РАБОТАЛ В ИНТЕРАКТИВНОМ РЕЖИМЕ, -t говорит, чтобы мы работали из терминала убуту

В линукс не тгрфической подсистемы. Она идёт дополнительным модулем. Это называется X-сервер

Чтобы запустить графическое приложение на удалёном дисплее нужно устаовить х11-apps
sudo apt install x11-apps
Чтобы х11 знал на какой дисплей отображать графическое приложение нужно прописать в переменную айпи дисплея:
DISPLAY=192.168.1.60:40 xclock & -- где 40 - это номер дисплея, xclock приложение часов, а & чтобы запуск графического приложения не заблокировал терминал, чтобы графические часы выполнялись независимо от горафической оболочки
А теперь рассмотрим как открыть рабочий стол линукс на винде
sudo apt xfce4
DISPLAY=192.168.1.60:40 startxfce4 & -- амперсант чтобы терминал не заблокировался

Дисплей каждый раз писать достанет. Не лучше ли его экспортировать?
export DISPLAY=192.168.1.60:40

Но чтобы даже этого не делать отредактируем башрц

vi ~/.bashrc

И тепереь мы вставляем туда то же самое
export DISPLAY=192.168.1.60:40
И выйдем
:wq




Ещё можно через виртуальную коробку запустить лубунту, ибо она лёгкая для ОС









Командная оболочка -- это то, через что мы взаисодействуем с командной строкой.
Sh самая базовая
Bash самый популярный
Zch используется в маке
Fish самая модная

В виндоус wsl --install

cd .. - переход на папку выше
cd - - переход обратно
mkdir - создать папку
ls понятно, а что, если мы хотим увидеть что лежит в директории вместе в нашей папкой?
ls ..
А если мы хотим выйти из нашей директории и посмотреть другую папку?
ls ../volume

дЛЯ ТОГО, ЧТОБЫ СОЗДАТЬ файл
touch text.txt

Чтобы переместить файл в директорию
mv text.txt /dir

С помощью этой функции можно и переименовывать файл
mv text.txt text1.txt

Также мы можем копировать
cp text1.txt text2.txt - если нет - создаст
Чтобы удалить 
rm text2.txt

-r - всю папку
cp -r
mv -r
rm -r

echo 'Hello'

stdin (or [0])
stdout (or [1])
stderr (or [2])

echo 'Hello' > &2 -- направляем данные во второй поток (в поток ошибок, то есть это теберь представление ошибки)
echo 'Hello' > text2.txt -- прописать в файл text2.txt
Если хотим добавить, то не >, потому что это перезапишет файл, а >>, что добавит

grep Goog text1.txt -- найти все слова с буквами Goog
find . -name text2.txt -- найти этот файл
find . -name *.txt -- найти файл с таким расширением
find . -name *.txt -type f --распечатай нам файлы и файлы в папках с расширением








Pipe - это канал межпроцессорного взаимодействия.
Этот конвейер чаще используется для запуска нескольких команд путём перенаправления вывода одной команды на вход последующей. Чтобы разделить команды используют |
ps aux | grep bash -- выведи все процессы, в названиях которых есть слово bash
ps aux | grep bash | gper -v grep -- но исключить все процессы, в которых есть слово grep

echo 'text1.txt text2.txt text3.txt' | xargs touch --создат все файлы
echo 'text1.txt text2.txt text3.txt' | xargs rm -- удалит все файлы






Посисадминим, пацаны?
groupadd newgroup -- создадим группу
useradd -G newgroup -p password newuser -- добавит newuser в newgroup с паролем
groups

Теперь выведем все папки:
ls -l
d -- папка
- -- файл
rwx - читать писать исполнять файл
Так три группы rwx. Понятно: есть r-x, r-- и так далее. 
Первая группа: права пользователя-создателя файла или директории
Вторая группа: права групп на файл или директорию (группа, где находится пользователь, кроме пользователя)
Третья группа: остальные пользователи
Дальше количество жёстких ссылок
Дальше имя пользователя-создателя
дальше группа создателя
Дальше размер и дальше всё понятно

Настраиваем права доступа к файлу text1.txt
r - имеет стоимость 4
w - имеет стоимость 2
x - имеет стоимость 1

chmod 400 text1.txt - только читать можно МНЕ!
chmod 644 text1.txt - читать и писать можно только мне, а остальным только читать

А если мы хотим передать права другому пользователю?
chown user:group text1.txt -- открепи от себя права на rw- и передай из user



nano text1.txt --открой в терминале файл контрл+о дальше пишем файл в котором хотим сохранить, энтер и ктрл икс
или дебильный vim, выйти из которого можно только нажав эск для прерывания редактирования файла и прописать :wq! для сохранения его и выхода из оболочки

Что значит пингуем сайт? Проверяем работу
ping 8.8.8.8 или ping google.com

дальше интересней
ПОДКЛЮЧЕНИЕ К УДАЛЁННЫМ СЕРВЕРАМ!
ssh root@80.78.240.77
И работать через терминал с ним

Скопироать файл с удалённого сервера к нам
scp root@80.78.240.77:file.txt /my/path/
И обратно
scp file.txt root@80.78.240.77:/root/

curl www.yandex.ru -- даст какйю-то инфу с сайта





Bash-скрипты

Набор команд в файле для выполнения

Сначала идёт первая строка шибанга #!bin/bash в фале с расширением .sh.
Чтобы запустить:
./script.sh
or
bash script.sh
or
source script.sh

Чтобы отнять право на выполнение файла:
chmod -x script.sh

Есть переменная:
$VALUE = 'Hi' -- большими буквами всегда

Обратиться к ней можно через знак $
ehco $VALUE
echo "$VALUE" -- обязательно двойные, потому что если использовать '', то мы просто распечатаем называние переменной.
echo "${VALUE}"

Чтобы увидеть все переменные, находящиеся на компе:
env

Как делать условия?
VALUE = 1
if [ "$VALUE" -eq 1 ]; then -- перед всеми скобками пробел
    echo 1
else
    echo 0
fi

В одну строку

VALUE = 1; [ "$VALUE" -eq 1 ] && echo 1 || echo 0

Циклы:

INTEGER = 0

while [ "$INTEGER" -le 5 ]; do -- -le это <=
    echo "$INTEGER"
    INTEGER = $(( INTEGER + 1 ))
done

Вызываем файл, которого не существует и выводим статус выполнения этой команды
cat file.txt
Ошибка
echo "$?"
1 -- бфла Ошибка
0 -- всё выполнилось нормально в предыдущей команде

Если прав нет на выполнение файла, но есть право у других, то просто перед командой вводим sudo

ls -z>>file3 2>&1
Все файлы и каталоги из текущей директории заархивировать в файл file3.zip и, в случае возникновения ошибок (stderr), перенаправить их (stdout предыдущей команды) в тот же архив.

Щас перепишем в одну строку:

INTEGER = 0

while [ "$INTEGER" -le 5 ]; do -- -le это <=
    echo "$INTEGER"
    INTEGER = $(( INTEGER + 1 ))
done

INTEGER=0; while [ "$INTEGER" -le 5 ]; do echo "$INTEGER"; INTEGER=$(( INTEGER + 1 )); done -- ОБРАТИ ВНИМАНИЕ НА ПРОБЕЛЫ!!!!!!!!!!!!!!











Сервера:

Три типа:
dedicated server - аренда сервера. В этом случае получают полный контроль над ним: установить ОС или ПО, обеспечить безопасность и обслуживание
virtual private server использует виртуализацию на уровне ОС, чтобы разделить физические ресурсы физического сервера на несколько виртуальных серверов. Каждый VPS работает в совей собственной виртуальной среде и имеет свои вычислительные ресурсы: ЦПУ, ОЗУ, ПЗУ. при этом вам доступна только ОС сервера.
virtual dedicated server использует гипервизор, ятобы разделить ресурсы физического сервера на несколько виртуальных.
SaaS -- это модель облачных вычислений, при которой провайдер облачных услуг предоставляет пользователю ПО как к услуге.
При хостинге сервера с SaaS-решением выполучаете доступ к приложению, которое запущено на удалённом сервере провайдера.То есть вы получаете конкретный софт. При этом ам могут быть доступны несколько экземпляров приложений.

Выделяют два режима доступа к удалённому серверу:
    ДЕмонстрация экрана позволяет просматривать экран удалённого сервера бнз возможности управлять им. Этотрежим подходит для наблюдения за работой сервера и отслеживания процесса без вмешательства.
    Полное управление позволяет управлять работой сервера.

Для подключения к удалённому серверу используются разные протоколы:
    SSH, Security Shell - протокол удалённого доступа к командной строке юникса или винды. Он позволяет управлять удалённым сервером и перенаправлять на него локальные проты. Один из самых распространённых.
    FTP практически не используется, потому что он небезопасный
    SCP - протокол безопасного копирования файлов между локальной и удалённой машины через SSH
    RDP - протокол для удалённого управления виндой через коандную строку.

Если клиент обращается к серверу по SSH, то на сервере уже запущен протокол SSHD с фиксированным портом 22

Для управления SSH-сервером:
    Git Bash
    PuTTY - если все через команднцю строку, то этот через графический интерфейс.

Кстати команда линукс scp работает по протоколу SCP между компом и сервером
Такая же хрень и WinSCP

Как подключится к remote server on SSH on Linux?

ssh user@server.org -- если есть имя сервера
ssh user@128.435.45.13 -- если имени нет
Теперь мы работаем с ним и, допустим, можем вывести содержимое через ls
А закрыть соединение с сервером с сервером logout
Exit? Закрыть командную строку?Не совсем хороший способ завершения работы с терминалом. Лучше нажать ктрл д. Так терминал поймёт, что команд больше не будет.
Управлять сервером через винду можно через PuTTY

Есть два типа подключаения: логин/пароль, подключение через SSH ключ.
Первое понятно.

Передача данных через SSH-ключ безопаснее. На компе лежит шифровщик файла (первая половина SSH-ключа) и на сервере лежит дешивровщик (вторая половина SSH-ключа).
То есть если мы отправляем "Привет", он шифрует cp+1234ox-@, на сервере дешфруется и спрашивает у компа "Это ты ли вводил?"

Чтобы подключатся к серверу без пароля, требуется отправть серверу SSH-ключ
Чтобы найти команду для подключения: github key ssh вводим в поисковик
ssh-keygen -t ed25519 -C "username@server" -- и для винды и для линукса
Он дальше предложит сохранить в папке файл с ключём
Но нам же надо отправить ключ на сервер, верно?
Пишем:
cat путь/до/файла/.ssh/id_ed25519.pub | ssh username@server "cat >> .ssh/file2"
Выводим содержимое id_ed25519 как бы в файл file1.pub| подключаемся к серверу через ssh и записываем из файла в новый файл file2.pub Уже на сервере. Таким образом у нас появился SSH-ключ и на сервере, и на компе.
Если папки .ssh нет на сервере, тогда пишем:
cat путь/до/файла/.ssh/id_ed25519.pub | ssh username@server "mkdir .ssh && cat >> .ssh/file2"

Теперь по логике вещей при входе на сервер у нас не спросят пароль.
Кстати на гитхаб можно подключить свой сервер

Теперь нужно запустить питон-сервер на сервере.
python3 -m http.server 5000 -- мы вызываем модуль http.server и открываем сервер на порту 5000. Он позволяет в браузере видеть те папки и файлы, откуда порт запускается.
Дальше в адресной строке браузера: server:5000
А теперь нам нужно узнать процессы питона на сервере 
ps aux | grep python3

Или можно проще:
htop -u eduson -- выведи все процессы с юзером едусон
Можно, конечно, завершить работу сервера через SIGTERM htop-а, но можно это сделать так:
kill 1234 -- где 1234 является идентификатором процесса.

Чтобы работа не завершилась простым закрытием терминала (а она так завершится), то нам нужно разобраться что такое мультиплекс
То есть когда родительский процесс завершается, нужно чтобы его дочерние не завршались.
Есть мультиплексорные терминалы: скрин и тмукс
для того, чтобы запустить
screen - дальше нужно открыть терминал внутри терминала нажатием пробела
screen -list -- посмотреть все запущенные сервера
screen -r 1234 -- перейти в терминал этого сервера
screen -S falsk -- создать терминал falsk
curl 127.0.0.1:5000 -- посмотреть порт 5000
ufw status -- проверить открытые порты












Что такое туннель?

Способ передачи данных между двумя узлами через другой протокол, про этом данные не обрабатываются, а только передаются.
Вы можете создать туннель через VPN или SOCKS. Это прокси-серверы, которые обеспечивают безопсность и анонимность в интернете. Они работают на разных уровнях и выполняют разные задачи.

VPN создаёт зашиврованный туннель между устройством пользователя и сервером ВПН. Весь трафик, проходящий между этими устройствами, защищен шифрованием, что обеспечивает конфиденциальность и безопасность передачи данных.

SOCKS или SOCKetS позволяет перенаправлять трафик приложений через прокси-сервер.

Вот есть у нас файл app.py:

from flask import Flask
app =Flask(__name__)

@app.route("/")
def hello():
    return "Hello!"

app.run(port=3000)

Дальше в новой строке пишем python3 app.py

Пишем в адресной строке: server:3000
Hello! 

Всё отлично! Всё выводится!
А что будет, если мы хотим поменять порт?
ssh -NL localhost:1234:localhost:3000 username@server -- теперь мы сменили порт 3000 на 1234

Но, чёрт возьми, с ГУИ работать удобней с WinSCP














Логи 

Логи в линуксе хранятся в директории var/log
Инвестигирование -- что произошло, судя по логам
Для сбора статистики есть утилита Splunk
Естественно, чтобы посмотреть логи
sudo ls -l var/log
sudo head -15  /var/log/Xorg.0.log.old -- чтобы посмотреть логи первые 15 строк
sudo tail -15  /var/log/Xorg.0.log.old -- чтобы посмотреть логи последние 15 строк
sudo ls -itr --проитерируйся и выведи каждую строку

Можно ещё использовать less. Он просто не загружает файл целиком и его можно просматривать построчно.
sudo less var/lg/message
Мы можем там писать после двоеточия /text и он нам подсветит все совпадения
grep "as .* df" text.txt -- найти все строки с таким текстом as (что-то между) df

1 сент 23:43:56 Георгий Ошибка: не то значение [8v]
perl -ne '/Георгий (.*): не то значение (.*)/ && print "$1 -> $2"'
Выражение сверху выведет "Ошибка -> [8v]"

Если мы хотим вывести только уникальные строки, тогда пишем | uniq

rsyslogd поддерживает работу с логами
systemd система инициализации, самый главный процесс







