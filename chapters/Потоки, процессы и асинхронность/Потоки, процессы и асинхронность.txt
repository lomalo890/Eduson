Многозадачность -- возможность выполнять несколько задачи параллельно. Ускорение и эффективное пользование железом.
Последовательное выполнение
РАспараллеливание нужно для усорения работы программистов.
Вытесняющая многозадачность -- это способ выполнения нескольких задач путём быстрого переключения между ними.

состояние гонки (race condition) или неопределённость параллелизма -- ситуация, когда результат зависит от порядка, в котором выполняются программы или подзадачи.
Чтобы избежать состояние гонки, нужно обеспечить потоковую безопасность
Потокобезопасные операции - операции, которые дают всё время одинаковый результат, независимо от того, выполняютсяя они параллелльно или нет.
Непотокобезопасные -- операци, результат которых может меняться в зависимости от порядка выполнения шагов внутри задач.

Старые ЯП не предоставляют инструментов для потоковой безопасности. В Python есть -- это примитивы синхронизации (mutex (замок), семафор)
mutex запрещает параллельный доступ к объекту, то есть читать и записывать данные может только одна операция. Другая операция не может начаться.
Deadlock -- состояние, когда потоки не могут закончить работу из-за того, что нужные ресурсы заблокированы другими потоками
Акторы -- две программы. Одна программа читает чётные числа, другая нечётные

Есть ещё семафор, то есть к объекту в одном потоке может обращаться несколько потоков
Есть Erlang и Elixir для акторов

global interpreter lock --запрещает нескольким потокам работать одновременно. Многозадачность достигается через постоянное переключение между разными потоками. Внутри каждого потока выделяются атомарные операции. Переключение во времея этих операций невозможно  Когда операция завершилась, происходит переключение на другой поток.

Асинхронное програмирование заключает в себе возможность для программиста, когда переключение между корутинами (подпрограммами) может происходить, а когда не может.
Кооперативная многозадачность -- вид многозадачности, при котором выполнение не прерывается, а передаётся другим программам.
В некоторых ОС есть кооперативная многозадачность, то есть выполнение одной операции может передаваться другой программе. Такие ОС называют файберами.
Есть CPU-bound task - зависит от процессора.
Есть I/O-bound task - зависит от устройств ввода-вывода
I/O-bound task зависит от запроса и, в большинстве своём, из ожидания. (запрашиваем у сети видео)
Он также может быть блокирующим и нет.
А для ускорения CPU-bound задач можно добавлять ядра процессора в работу.
В I/O-bound task для ускорения работы надо избегать блокировок других задач. То есть сетевая карта при заполнении от скачивания файла, говорит компу Эзабери эти данные, а я продолжу дальше скачивать".
Распределённые вычисления -- это способ запустить программу на нескольких устройствах одновременной. То есть 100 компов соеденины с сервером. Они дают серверу свои выисления и сервер выдаёт финальный результат.
Publish-Subscribe -- тип взимодействия устройств, в котором устройства могут меняться данными друг с другом.
То есть они связаны общей почтой -- менеджером очередей (RabbitMQ, Kafka)


Для распараллеливания есть ThreadPooExecutor из модуля concurrent.future

integers = [1,6,3,8,5,2,6,9,54,2,6,9,5,36,2]

start = time.monotonic() # Сохраняем время начала программы
executor = ThreadPoolExecutor() # Создаём с максимальным количеством потоков по умолчанию
for integer in integers:
    executor.submit(squire, integer) # Приводит все элементы списка в квадрат
executor.shutdown # Он нам нужен теперь? Нет.

Вот так программа может выполниться за 4 секунды, а мы ускорили её на две.

submit(squire, integer) == map(squire, integer)

Также мы можем с помощью with создать и закрыть потоки

with ThreadPoolExecutor() as executor:
    executor.map(squire, integer)















