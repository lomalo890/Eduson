class Persone:
    def __init__(self):
        ...
p = Persone()
print(p) #__main__

class Person:
    planet = 'Earth'

    __init__(self, name):
        self.name = name

Мы не ожем сделать вот так:
Person.name

Но можем сделать вот так:
Person.planet

Вызывается cначало магический метод __new__, который принимает на вход называние класса его позиционированные и именованные аргументы в неизвестном количестве, потом вызывается магический метод __init__
Метод __new__ пишется так:

def __new__(cls, *args, **kwargs):
    return suoer().__new__(cls) обращаемся к папе и говорим ему создай меня

Как работает?

person = Person.__new__(Person)
person = Person.__init__(p, name='George')

Объявили метод:

def song(self, song='lalala'):
    print(song)

Мы можем вызвать его двумя способами:
p.song()
Person.song(p, song='lalalala')











Инкапсуляция в питоне работает только с приват, то есть с двумя нижними _, но всё равно есть способ: persone._Person__secret Также и с методами
Цель инкапсуляции менять сосотояние через действие.



super() -- родительский класс

Иллюстрация правильного наследования:


class A:
    def present(self):
        print('B')


class B:
    def present(self):
        print('B')


class C(A, B):
    def present(self):
        print('C')


class D(B, A):
    def present(self):
        print('D')


class MetaMRO(type):
    def mro(cls):
        return (A, cls, B, D, C, object) #определяет порядо выполнения наследования


class E(D, C, metaclass=MetaMRO): #он не будет знать от кого переопределять метод, поскольку они сами наследуются от классов с этими методами. Чтобы избежать ошибки, пишется класс MetaMRO
    def present(self):
        print('E')
















Лексический анализатор -- не написал ли пользователь лишнего?


У нас есть два класса кошки и собаки, которые наследуются от животных, у которого есть говорящий метод. Каждый класс этот метод переопределяет метод: собака гав-гав, кошка мяу-мяу.
Теперь нам нужно сделать метод, автоматически определяющий класс животного и выводящего говорящий метод.

animal = {
    'Dog': Dog
    'Cat: Cat
}

main(animal):
    return [animal].talk()

main('Dog') # гав-гав
main('Cat') № мяу-мяу

Абстрактные методы можно использовать как интерфейсы

Чтобы создать абстрактный класс, нужно импортировать модуль ABC и пометить хоть оди метод абстрактным

from abc import ABS, abstractmethod

class Animal(ABc):
    def __init__(self, name):
        self.name = name

    @abstractmethod
    def talk():
        print('Я животное')

Теперь все дочерние классы должны этот метод определять, иначе экземпляр класса не создастся. Метод __init__ переопределять не нужно.
