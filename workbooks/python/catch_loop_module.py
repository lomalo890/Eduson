"""
награмма — это слово, которое можно составить с по-
мощью перестановки букв другого слова. Например,
в английском языке анаграммами являются слова «live»
и «evil», а в русском — «выбор» и «обрыв». Напишите
программу, которая будет запрашивать у пользователя
два слова, определять, являются ли они анаграммами,
и выводить на экран ответ.
"""

def is_anagram(word1, word2):
    return word1[::-1] == word2







"""
Количество дней в месяце — от 28 до 31. Ваша программа
должна запрашивать у пользователя название месяца
и отображать количество дней в нем.
Поскольку годы мы не учитываем, для февраля можно
вывести сообщение о том, что этот месяц может состоять
из 28 или 29 дней, чтобы учесть фактор високосного года.
"""

def months(month):
    months = {
        'Январь': 31,
        'Февраль': '28 or 29',
        'Март': 31,
        'Апрель': 30,
        'Май':31,
        'Июнь': 30,
        'Июль': 31,
        'Август': 31,
        'Сентябрь': 30,
        'Октябрь': 31,
        'Ноябрь': 30,
        'Декабрь': 31
    }
    return months.get(month)






"""
В зоопарке цена входного билета зависит от возраста
посетителя. Дети до двух лет и пенсионеры старше 65 лет
допускаются бесплатно. Дети в возрасте от трех до 12 лет
могут посещать зоопарк за 200 рублей. Обычный взрос-
лый билет стоит 500 рублей.
Напишите программу, которая будет запрашивать
возраст всех посетителей в группе по одному за раз
и выводить общую цену билетов для посещения зоопарка
этой группой. Общую цену билетов стоит выводить в
формате с двумя знаками после запятой
"""

def zoopark():
    cost = 0
    while True:
        age = int(input('Чтобы завершить ввод, введите -1'))
        if age == -1:
            break
        elif age <= 2 or age > 65:
            continue
        elif age > 2 and age < 12:
            cost += 200
        else:
            cost += 500
    return cost






"""
Напишите функцию для определения количества дней
в конкретном месяце. Ваша функция должна принимать
два параметра: номер месяца в виде целого числа
в диапазоне от 1 до 12 и год, состоящий из четырех цифр.
Убедитесь, что функция корректно обрабатывает фев-
раль високосного года.
Запросите у пользователя номер месяца и год и выведите
на экран количество дней в указанном месяце
"""

def months(month, year):
    if year % 4 == 0:
        febrary = 29
    else:
        febrary = 28
    months = {
        'Январь': 31,
        'Февраль': febrary,
        'Март': 31,
        'Апрель': 30,
        'Май':31,
        'Июнь': 30,
        'Июль': 31,
        'Август': 31,
        'Сентябрь': 30,
        'Октябрь': 31,
        'Ноябрь': 30,
        'Декабрь': 31
    }
    return months.get(month)

"""
смотреть Screenshot from 2024-09-21 15-59-37.png
"""

def output_y(x, y):
    if x != 5:
        y = y + 2 * y - 3
        x -= 1
        return output_y(x, y)
    elif x == y:
        x = x + y
        y = y - x
    else:
        x = x - y
        y = y + x
    return y

"""
Юлию Цезарю необходимо было посылать секретные
письменные приказы своим генералам. В результате
он стал шифровать свои послания довольно простым
методом, который теперь называют кодом Цезаря.
Идея шифрования заключалась в циклическом сдвиге
букв на три позиции. В итоге буква A превращалась в D,
B – в E, C – в F и т. д. Последние три буквы алфавита
переносились на начало. Таким образом, буква X
становилась A, Y – B, а Z – C.
Цифры и другие символы не подвергались шифрованию.

Важно: буквы идут по алфавиту в кодировке Юникод.
Большие и маленькие буквы находятся в кодировке
в разных местах, поэтому обрабатывать переход нужно
отдельно для заглавных и строчных букв.
Для проверки символов можно использовать функции
isalpha() — буква ли это, и isupper() — заглавная ли
это буква.
Напишите программу, которая реализует код Цезаря
для латинского алфавита. Позвольте пользователю
ввести фразу, после чего выведите результат
"""

def cezar(text):
    alphabet_upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    alphabet_lower = alphabet_upper.lower()
    for i in range(len(text)):
        if text[i] in alphabet_upper:
            text[i] = alphabet_upper[i + 3]
        elif text[i] in alphabet_lower:
            text[i] = alphabet_lower[i + 3]
    return text








"""
Изучите список:

a = [1, 1, 2, 3, 5, 8, 34, 55, 89].

Напишите код: выведите все элементы списка, которые
меньше 5
"""
def min_five(lst):
    l = []
    for el in lst:
        if el < 5:
            l.append(el)
    return l






"""
смотрите Screenshot from 2024-09-21 16-15-45.png
"""

def process(a, b, c):
    if a == b:
        c = a + b
        e = b + c
    elif b < c:
        a = a + b
        e = a + c
    else:
        b = c + b
        e = a + b
    return e






"""
Напишите программу для отображения стандартной
таблицы умножения от единицы до десяти. Убедитесь,
что ваша таблица умножения имеет заголовки над пер-
вой строкой и слева от первого столбца.
"""

def multik():
    l1 = [1,2,3,4,5,6,7,8,9,10]
    l2 = []
    l3 = []
    for i in l1:
        for j in l1:
            l3.append(j * i)
        l2.append(l3)
        l3 = []
    for i in l2:
        print(*i)

multik()






"""
Для выигрыша главного приза нужно, чтобы 6 номеров
на лотерейном билете совпали с шестью числами, кото-
рые выпали случайным образом в диапазоне от 1 до 49.
Напишите программу, которая будет случайным образом
подбирать шесть номеров для вашего билета. Убедитесь,
что среди этих чисел не будет дубликатов. Выведите
номера билетов на экран по возрастанию.

Важно: в коде используйте функцию random.sample()
"""

import random 

def generate_random_numbers(*args):     
    numbers = random.sample(range(1, 50), 6)
    for integer in numbers:
        if integer in args:
            continue
        else:
            return False
    return True

"""
Напишите программу, которая будет запрашивать
у пользователя целочисленные значения и сохранять
их в виде списка.
Чтобы закончить ввод значений, пользователь должен
ввести 0.
Затем программа выведет на экран все числа, кроме 0,
в порядке возрастания — по одному значению в строке.
"""

def list_integers():
    numbers = [] 
    while True: 
        number = int(input("Введите целое число: ")) 
        if number == 0: 
            break 
        numbers.append(number) 
    return numbers








"""
Напишите программу, которая будет складывать числа,
введенные пользователем.
Сигнал к окончанию ввода — пустая строка.
Отобразите на экране сумму значений. Если пользова-
тель сразу же пропустил ввод, выведите 0.0. Решите эту
задачу с использованием рекурсии. В вашей программе
не должны присутствовать циклы.

Важно: запросите одно число у пользователя в теле
вашей рекурсивной функции. После этого должно быть
принято решение, производить ли еще один рекур-
сивный вызов.
Ваша функция не должна принимать аргументов, а воз-
вращать будет числовое значение.
"""

def add_numbers():
    user_input = input("Введите число: ")
    if user_input == "":
        return 0.0
    else:
        return float(user_input) + add_numbers()
    





"""
Гарри, Рон и Гермиона отправляются на поиски крестражей. Как им удалось узнать, 
один из крестражей спрятан в хранилище Гринготтса — специального банка для волшебников.

Друзья приняли решение использовать зелье невидимости. Лучше всего это зелье работает в туманную погоду.

Помогите волшебникам выбрать дни для поиска крестражей. Создайте функцию search_day(), 
которая посчитает количество туманных дней в списке. Она принимает в качестве аргумента 
список с предположительной влажностью воздуха на ближайшие пять дней. Например, такой: 
76, 89, 91, 32, 10. Если влажность превышает 80%, день считается туманным. Верните список 
с порядковыми номерами туманных дней. Номера дней считайте с нуля.
"""

def search_day(percents):
    days = []
    i = 0
    for percent in percents:
        if percent > 80:
            days.append(i)
        i += 1
    return days
    
array = [76, 89, 91, 32, 10]
print(search_day(array))










"""
Теперь, когда волшебники определились с днем, в который они проникнут в Гринготтс, им 
необходимо распределить задачи между собой. Гермиона составила список задач:

    Приготовить зелье невидимости.
    Собрать вещи и подготовить снаряжение.
    Раздобыть это оборотное зелье.

Чтобы распределить задачи честно, Гермиона заколдовала три стакана с водой. Если 
дотронуться до стакана волшебной палочкой, вода в нем поменяет цвет. Каждому цвету 
соответствует своя задача:

— если цвет окажется красны1, то волшебник займется первой задачей;

— если цвет окажется синий, то волшебник займется второй задачей;

— если цвет окажется зеленый, то волшебник займется третьей задачей;

— если волшебнику выпадет любой другой цвет, значит, заклинание сработало некорректно.

Напишите программу, которая поможет волшебникам определить, какой задачей им нужно 
заняться. Создайте функцию task_check(), которая принимает на вход строку с названием 
цвета. Цвета передаются на английском языке. Функция должна вернуть номер задачи, 
которой соответствует цвет, или ноль, если цвету не соответствует ни одна задача.
"""

def task_check(color):
    if color is 'красный':
        return 'Приготовить зелье невидимости.'
    elif color is 'синий':
        return 'Собрать вещи и подготовить снаряжение.'
    elif color is 'зеленый':
        return 'Раздобыть оборотное зелье.'
    else:
        return 'это заклинание сработало некорректно'







"""
Гермионе выпала первая задача — она должна приготовить зелье невидимости. У этого зелья 
несложный рецепт, но нужно быть очень внимательной.

Гермионе нужно помешивать зелье конкретное количество раз, чтобы оно получилось правильным. 
Она помечает все помешивания на пергаменте. Общее количество помешиваний должно соответствовать 
одному из условий:

— делится на 4 и не делится на 100;

— делится на 400.

Напишите функцию potion_check(), которая проверит, помешала ли Гермиона зелье правильное 
количество раз. Она должна принимать на вход один аргумент — число, которое обозначает, 
сколько раз Гермиона помешала зелье. В качестве результата работы функции верните yes, 
если количество помешиваний верное, или no в обратном случае. Используйте операторы 
and и or, чтобы скомбинировать несколько условий в одном if.
"""

def potion_check(integer):
    if integer % 4 == 0 and integer % 100 != 0 or integer % 400 == 0:
        return 'yes'
    else:
        return 'no'











"""
Рону досталась вторая задача — собрать вещи и подготовить снаряжение. 
Рон составил список необходимых вещей:

— мантия-невидимка;

— волшебная палочка;

— набор зелий;

— карта;

— оберег от проклятий.

Рон не очень внимательный и боится забыть что-то важное и взять что-то 
лишнее. Помогите ему — создайте функцию importance_check(), которая 
проверит, нужно ли брать предмет с собой. Она принимает на вход один 
аргумент — название предмета, который можно взять. Названия предметов 
передаются на русском языке, все необходимые предметы называются так же, к
ак они названы в списке выше. Если предмет входит в список и его нужно взять, 
верните 1. Если не входит — значит, брать его не нужно, верните 0.
"""

def importance_check(good):
    goods = [
        'мантия-невидимка',
        'волшебная палочка',
        'набор зелий',
        'карта',
        'оберег от проклятий',
        ]
    if good in goods:
        return 1
    else:
        return 0
    








"""
Гарри досталась третья задача — приготовить оборотное зелье. Заготовку для зелья 
достать не составило труда, но чтобы оно сработало верно, Гарри необходим волос 
одного студента Дурмстранга. Студенты Дурмстранга близки к Темному Лорду, поэтому 
такая маскировка поможет проникнуть в Гринготтс. Помогите Гарри найти подходящего 
человека.

Известно, что фамилии всех студентов Дурмстранга в Лютном переулке оканчиваются "ов". 
Создайте функцию student_suspect(), которая определит, подходящая ли фамилия у предполагаемого 
студента. Функция принимает на вход один аргумент — строку с фамилией студента. Если фамилия 
оканчивается на "ов", верните «Лови!». В любом ином случае верните «Пропусти его».
"""

def student_suspect(family):
    if family.endswith('ов'):
        return 'Лови!'
    else:
        return 'Пропусти его'
    














"""
Подготовка не прошла даром — Гарри, Рону и Гермионе удалось проникнуть в Гринготтс. 
Они спустились к хранилищам и оказались в просторной комнате, в которой есть семь 
дверей. Только одна из них безопасная, за остальными скрываются ловушки.

На каждой двери есть номер из четырех цифр. Если номер является палиндромом, то дверь 
безопасна. Палиндром — это строка, которая одинаково читается в обоих направлениях. 
Например, строка «1331» — это палиндром.

Напишите функцию security_check(), которая проверит, безопасно ли выходить через определенную 
дверь. Функция принимает один аргумент — строку с последовательностью цифр на двери. 
Проверьте, является ли строка палиндромом. Если да, то верните «Безопасно». В любом ином 
случае верните «Ловушка».
"""

def security_check(number):
    string = str(number)
    return 'Безопасно' if string == string[::-1] else 'Ловушка'













"""
Благодаря вам Гарри, Рон и Гермиона успешно проникли в Гринготтс, добыли крестраж и избежали ловушек. 
Отличная работа! Осталась последняя, но не менее сложная миссия — сбежать из Гринготтса. 
В этом волшебникам поможет дракон, который охраняет банк.

На ошейнике дракона есть кодовый замок, код к нему состоит из 4-х цифр. Чтобы он открылся, 
сумма всех цифр должна делиться на 7. К сожалению, замок заело — волшебники могут 
изменить только одну цифру.

Создайте функцию cipher(), которая определит, какую цифру нужно ввести волшебникам 
в четвертом слоте замка. Она принимает на вход три аргумента — три цифры, которые 
уже введены в кодовый замок. В результате работы функции верните ту цифру, которую 
волшебникам нужно ввести в оставшийся слот. Если никакая цифра не подходит, замок 
взломать нельзя. В таком случае верните 0.
"""

def cipher(integer1, integer2, integer3):
    code = integer1 + integer2 + integer3
    if code % 7 == 0:
        return 0
    for i in range(1, 8):
        if (code + i) % 7 == 0:
            return i
        

















"""
КиберКодер — известный в узких кругах хакер. Уже много лет его занимает одна задача. 
Он хочет взломать шифр, за которым прячется ответ на главный вопрос Вселенной. 
КиберКодеру очень бы пригодилась ваша помощь.

Для первого этапа взлома КиберКодеру нужно подобрать номера портов сервера, к которым 
он сможет подключиться. Известно, что это четные числа, которые находятся в 
определенном диапазоне.

Напишите функцию even_numbers(), которая найдет все четные числа в диапазоне. 
Она принимает два аргумента — начало и конец промежутка, внутри которого нужно будет 
найти четные цифры. Сохраните в список все четные числа в заданном диапазоне и 
верните этот список в качестве ответа.
"""

def even_numbers(integer):
    integers = list(range(integer))
    evens = []
    for el in integers:
        if el % 2 == 0:
            evens.append(el)






















"""
Отлично, КиберКодеру удалось подключиться к серверу! Следующий шаг — 
найти номера директорий с файлами, которые отвечают за шифрование.

Известно, что важные файлы хранятся в директориях с нечетными номерами. 
Но следует быть осторожным — директория с номером 359 защищена особым 
файерволом. Если ее открыть, хакера тут же обнаружат.

Создайте функцию directories_check(), которая принимает один аргумент — 
список целых чисел. Каждое число в этом списке — это номер директории. 
Функция должна сохранить все нечетные номера в отдельный список и вернуть 
его в качестве ответа. Если в исходном списке встретилась директория с номером 
359, остановите проверку и сохраните только те нечетные числа, которые попали 
в список до 359. Число 359 не должно попасть в ответ.
"""

def directories_check(*args):
    l = []
    for arg in args:
        if arg == 359:
            return l
        elif arg % 2 == 1:
            l.append(arg)
    return l    













"""
Благодаря функции directories_check(), которую вы создали в предыдущем задании, 
КиберКодер собрал несколько списков директорий. Помогите ему определить самые 
важные из них, которые следует проверить. Самыми важными считаются директории, 
которые встречаются сразу в нескольких списках.

Создайте функцию crosscheck(), которая принимает на вход два аргумента — 
два списка целых чисел. Функция должна найти числа, которые есть сразу в 
двух списках. В качестве ответа верните список этих чисел. Используйте 
циклы для решения задачи.
"""

def crosscheck(list1, list2):
    max_list = list1 if len(list1) > len(list2) else list2
    min_list = list1 if len(list1) < len(list2) else list2
    lst = []
    for el in min_list:
        if el in max_list:
            lst.append(el)
    return lst









"""
Отлично, благодаря вашей помощи КиберКодер смог выбрать самые важные директории. Он получил 
доступ к засекреченным файлам, которые зашифрованы. Чтобы их расшифровать, КиберКодеру нужно 
рассчитать уникальные ключи. Уникальный ключ — это сумма всех цифр из номера директории.

Создайте функцию unique_key(), которая принимает один аргумент — целое положительное число. 
Функция unique_key должна найти сумму всех цифр числа из аргумента. Верните эту сумму в качестве 
ответа. Используйте цикл while для решения задачи.
"""

def unique_key(port):
    summa = 0
    integers = list(str(port))
    for i in integers:
        summa += int(i)
    return summa
















"""
КиберКодеру удалось расшифровать засекреченные файлы с вашей помощью! Внутри каждого 
файла оказалась длинная строка. Чтобы определить ее смысл, КиберКодер решил провести 
частотный анализ.

Частотный анализ — это метод расшифровки сообщений, который основан на поиске частоты 
повторения символов. С его помощью можно сопоставить частоту повторения букв в сообщении
 и в алфавите. Расшифровать текст можно, если заменить буквы зашифрованного сообщения на 
 соответствующие буквы стандартного алфавита.

Создайте функцию count_letters(), которая посчитает, сколько раз буква повторяется в строке. 
Функция должна принимать два аргумента — строку, которую нужно проанализировать, и букву, 
частоту повторения которой нужно найти. В качестве ответа верните одно число — количество 
повторений буквы в строке.
"""

def count_letters(string, letter):
    return string.count(letter)










"""
Частотный анализ помог КиберКодеру сопоставить буквы русского алфавита с буквами в зашифрованном 
сообщении. Хакер заменил все буквы в зашифрованном файле на цифры, которые соответствуют номерам 
букв в алфавите. Букве А он присвоил номер 0, букве Б — номер 1 и так далее. Помогите КиберКодеру 
расшифровать сообщение.

Напишите функцию decipher(), которая заменит все числа в строке на буквы русского алфавита. Функция 
должна принимать один аргумент — строку с целыми числами от 0 до 32, между которыми стоит пробел. 
В качестве ответа верните строку с последовательностью букв без пробелов и других разделителей. 
Используйте только строчные буквы.
"""

def decipher(string):
    alphabet = list('абвгдеёжзийклмнопрстуфхцчъыьэюя')
    integers = string.split(" ")
    s = ''
    for i in integers:
        s += alphabet[int(i)]
    return s


















"""
В конце концов КиберКодер узнал самую главную тайну. Она оказалась настолько страшной, что ее 
нельзя доверить ни одному человеку в мире. КиберКодеру придется вновь ее зашифровать.

Самые сложные шифры основаны на факторизации, то есть разложении чисел на множители. КиберКодер 
вновь просит вас о помощи.

Создайте функцию all_dividers(), которая найдет все делители числа. Она должна принимать на вход 
один аргумент — число, которое нужно разложить на множители. В качестве ответа верните список со 
всеми делителями исходного числа.
"""

def all_dividers(integer):
    l = []
    for i in range(1, integer + 1):
        if integer % i == 0:
            l.append(i)
    return l