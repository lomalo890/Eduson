'''Напишите функцию find_unique_elements, которая принимает 
на вход список lst и возвращает список уникальных элементов 
этого списка. Используйте встроенные функции. Отсортируйте результат 
по возрастанию.
'''

def find_unique_elements(lst):
    return sorted(list(set(lst)))

'''
Напишите функцию sums_by_quarter, которая принимает список чисел (показаний 
термометра с января по декабрь) и возвращает список сумм значений 
по кварталам. Каждый квартал состоит из трех месяцев, и список должен быть 
разбит на соответствующие кварталам элементы. При этом, каждый квартал должен 
быть представлен одним числом - суммой элементов в этом квартале. 
'''

def sums_by_quarter(lst):
    result = []
    for i in range(0, len(lst) - 1, 3):
        j = i + 1
        k = i + 2
        result.append(lst[i] + lst[j] + lst[k])
    return result


'''
Напишите функцию sorted_unique_list, которая принимает список чисел и возвращает 
список, отсортированный по возрастанию и без повторяющихся элементов. Используйте 
специальную функцию.
'''
def sorted_unique_list(lst):
    return sorted(list(set(lst)))

'''
Напишите функцию count_frequency, которая принимает список имен (строк) и возвращает 
словарь, содержащий количество упоминаний каждого имени в списке. Словарь должен быть 
отсортирован по ключам в алфавитном порядке.
'''

def count_frequency(names):
    return {k: names.count(k) for k in names}


'''
Напишите функцию flatten_nested_list, которая принимает в качестве аргумента 
вложенный список (список списков) и возвращает плоский список, состоящий из всех элементов вложенных списков.
'''

def flatten_nested_list(subber):
    result = []
    for element in subber:
        if isinstance(element, list):
            result = result + element
        else:
            result.append(element)
    return result


'''
Напишите функцию process_commands, которая принимает на вход список 
команд и выполняет их. Каждая команда представляет собой строку, которая 
может быть одной из следующих: * execute: добавляет текущий индекс 
выполнения команды в список результатов; * skip: игнорирует команду и 
переходит к следующей; * stop: прекращает выполнение команд.

Функция process_commands должна возвращать список всех индексов выполнения 
команд.
'''

def process_commands():
    id = 1
    lst = []
    command = ''
    while not 'stop' in command:
        command = input()
        if 'execute' in command:
            lst.append(str(id) + f' {command}')
        elif 'skip' in command:
            continue
        id += 1
    print(lst)

process_commands()








'''
Вы отправились в захватывающее приключение в лес, где перед вами открылась древняя 
дорога, разделяющаяся на три разных направления. Каждый путь предлагает уникальные 
испытания и возможности.

Вам необходимо реализовать функцию forest_adventure(path), которая принимает на вход 
строку path, представляющую выбранный путь - left, center или right. В зависимости от 
выбранного пути, функция должна возвращать текстовое описание того, что вас ожидает впереди.

    Создайте функцию forest_adventure(path), которая принимает на вход строку path - 
    left, center или right.
    Используя условные выражения, реализуйте аналог конструкции switch-case, чтобы 
    вернуть описание выбранного пути.
    Верните текстовое описание в зависимости от выбранного пути.

Пути:

left: Вы выбрали левый путь. По этому пути вы найдете старую пещеру с сокровищами. Остерегайтесь, 
внутри могут скрываться опасности, но, возможно, вы сможете обнаружить древние сокровища. center: 
Вы выбрали центральный путь. Здесь вас ожидает таинственный храм. Вам предстоит пройти испытание 
мудрости и смекалки, чтобы получить древние знания. right: Вы выбрали правый путь. По этому пути 
вы наткнетесь на племя дикой природы. Они согласны поделиться с вами своими тайнами, но сначала 
вам придется доказать свою отвагу в опасной схватке.
'''

def forest_adventure(path):
    match path:
        case "left":
            return "Вы выбрали левый путь. По этому пути вы найдете старую пещеру с сокровищами. Остерегайтесь, внутри могут скрываться опасности, но, возможно, вы сможете обнаружить древние сокровища."
        case "right":
            return 'Dы выбрали правый путь. По этому пути  вы наткнетесь на племя дикой природы. Они согласны поделиться с вами своими тайнами, но сначала вам придется доказать свою отвагу в опасной схватке.'
        case 'center':
            return 'Вы выбрали центральный путь. Здесь вас ожидает таинственный храм. Вам предстоит пройти испытание мудрости и смекалки, чтобы получить древние знания.'
        

'''

    Создайте функцию de_none(lst), которая принимает на вход список lst.
    Проходите по элементам списка и проверьте, равен ли какой-либо его элемент значению None.
    Если элемент списка не равен None, добавьте его в новый список res.
    Верните новый список res, который не содержит значений None.

'''

def de_none(lst):
    return [element for element in lst if element != None]


'''

    Создайте функцию segment(num, scale), которая принимает на 
    вход число num и список чисел scale, отсортированный по возрастанию. 
    Число num выбрано случайным образом в промежутке между минимальным и 
    максимальным значением в списке scale.

    Найдите минимальное и максимальное значение в списке scale.

    Проверьте, является ли num соседним числом справа или слева от другого числа в списке scale, или совпадает с числом в списке.

    Если num соседнее слева или справа, верните кортеж из двух соседних чисел.

    Если num совпадает с числом в списке, верните кортеж из двух одинаковых чисел.

    Если num не является соседним числом и не совпадает с числом в списке, верните None.

'''
        
def segment(num, scale):
    min_value = min(scale)
    max_value = max(scale)

    if num in scale:
        return (num, num)

    for i in range(len(scale) - 1):
        if scale[i] < num < scale[i+1]:
            return (scale[i], scale[i+1])

    return None




    
