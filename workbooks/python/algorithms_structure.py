"""
Дан одномерный массив числовых значений array с N элементами. Напишите функцию swap_groups, 
которая поменяет местами группу из M элементов, которые начинаются с индекса K, с группой из 
M элементов, которые начинаются с индекса P. Функция swap_groups должна вернуть измененный массив.

Например, на вход программы передали массив array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 
переменные N = 10, M = 3, K = 1 и P = 6. Функция swap_groups в таком случае должна поменять 
местами три элемента с индексами 1, 2 и 3 с тремя элементами с индексами 6, 7 и 8. 
В результате должен получиться массив [1, 7, 8, 9, 5, 6, 2, 3, 4, 10].

Используйте срезы массива, чтобы выделить группы элементов с индекса K и индекса P.
"""

def swap_groups(n, m, k, p):
    n = list(range(1, n + 1)) # [1,2,3,4,5,6,7,8,9,10]
    l1 = n[k:k + m] # [2,3,4]
    l2 = n[p:p + m] # [7,8,9]
    return n[:k] + l2 + n[(k + m):p] + l1 + n[(p + m):]




"""
Дан одномерный массив чисел array, в котором N элементов. Напишите функцию process_array, 
которая подсчитает, сколько чисел в массиве делятся на 3 нацело, и вычислит среднее 
арифметическое четных чисел. Функция process_array должна добавить эти значения в новые 
элементы на первом и последнем местах в массиве соответственно. Верните измененный массив 
в качестве ответа.

Например, на вход программы передали массив array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. 
В нем три элемента делятся нацело на 3, а среднее арифметическое четных чисел — 6. 
В результате должен получиться массив [3, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6.0].
"""


def process_array(array):
    three = [integer for integer in array if integer % 3 == 0 and integer != 0]
    average = [len(three)]
    return average + array + [sum(three) / 3]








"""
В игре «Битва карт» карточная колода раздается поровну двум игрокам, карты выдаются в 
случайном порядке. Игроки вскрывают по одной верхней карте, и тот, чья карта старше, 
забирает обе вскрытые карты и помещает их вниз своей колоды. Игрок, который остался 
без карт, проигрывает.

Все карты в колоде различны по номиналу, старшая карта побеждает младшую. Игрок, который 
забирает карты, кладет сначала карту первого игрока, затем свою карту вниз своей колоды.

Напишите программу, которая моделирует игру «Битва карт» и определяет победителя. В игре 
участвуют 10 карт со значениями от 0 до 9. Большая карта побеждает меньшую, карта со 
значением 0 побеждает карту 9 (и только ее).

Программа получает на вход две строки: первая строка содержит 5 чисел, которые разделены 
пробелами, — номера карт первого игрока, вторая строка — 5 карт второго игрока. Карты 
перечислены сверху вниз, то есть каждая строка начинается с карты, которая будет открыта первой.

Программа должна определить победителя при данной раздаче и вывести слово "first" или 
"second", а также количество ходов до выигрыша. Если игра не заканчивается за 100 ходов, 
между игроками ничья, программа должна вывести слово "tie". Для решения задачи используйте очередь.

Например, на вход программы передали две строки чисел: 1 3 5 7 9 и 2 4 6 8 0. В таком 
случае второй игрок победит первого за 5 ходов. Программа должна вернуть ответ second 5.
"""

def versus_cards(player1, player2):
    from random import shuffle
    count = 0
    player1 = [int(card) for card in player1.split()]
    player2 = [int(card) for card in player2.split()]
    deck = []
    while True:
        count += 1
        card1 = player1.pop(0)
        card2 = player2.pop(0)
        if card1 > card2 or (card1 == 0 and card2 == 9):
            player1.append(card2).append(card1)
        else:
            player2.append(card1).append(card2)
        if player1 == None or player2 == None:
            break
    
    if count < 100:
        return 'tie'
    elif player2 == None:
        return 'first'
    else:
        return 'second'
    







"""
Дана строка, которая состоит из круглых скобок. Создайте функцию row_check, 
которая определит, какое наименьшее количество символов необходимо удалить 
из этой строки, чтобы получилась правильная скобочная последовательность.

Правильная скобочная последовательность — это строка, в которой каждая открывающая 
скобка имеет соответствующую закрывающую скобку и скобки правильно вложены. 
Например, правильные скобочные последовательности могут выглядеть так: (), (()), 
(()(())). Неправильные скобочные последовательности выглядят так: (, ), ((), ())(.

На вход программы передается строка из круглых скобок. Длина строки не превосходит 
100 символов. Функция row_check должна вернуть одно число — минимальное количество 
символов, которые необходимо удалить. Используйте стек для решения задачи.
"""

def row_check(b):
    b1 = b.count(')')
    b2 = b.count('(')
    return b1 - b2 if b1 > b2 else b2 - b1

# no right understant

def row_check(s):
    stack = []
    count = 0
    for char in s:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if stack:
                stack.pop()
            else:
                count += 1
    count += len(stack)
    return count








"""
Напишите функцию graph_check, которая проверяет, является ли заданный неориентированный граф связным.

Связный граф — это такой граф, в котором существует путь между любыми двумя его вершинами. 
То есть из одной его вершины можно добраться до любой другой. Граф задается списком ребер.

На вход программы три аргумента. Два числа — количество вершин графа V и количество ребер E. 
Третий аргумент — список длиной E, где каждый элемент — это кортеж из двух чисел u и v. Число u — 
это номер вершины, из которой ребро выходит. Число v — номер вершины, в которую ребро приходит. 
Программа должна вернуть ответ YES, если граф является связным, и NO в любом ином случае. 
Используйте DFS для решения задачи.

Сохраните ребра графа в многомерный список. Каждый элемент такого списка — это две вершины, 
которые составляют ребро.
"""

def graph_check(array):
    from itertools import combinations
    array = [tuple(sorted(tup)) for tup in array]
    tup = list(set(sum(array, ())))
    comb = list(combinations(tup, 2))
    return all(tup in array for tup in comb)
    


array = [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4), (2, 4)]












"""
Дано бинарное дерево поиска, в котором каждый узел содержит ключ 
(уникальное целое число) и ссылки на левого и правого потомка. 
Напишите функцию find_max_key, которая находит узел с максимальным 
ключом в этом дереве.

Функция find_max_key принимает на вход корень root бинарного дерева. 
В результате функция должна вернуть значение максимального ключа в дереве. 
Если дерево пустое, верните 0. Для обхода бинарного дерева поиска 
используйте рекурсивную функцию.
"""

def find_max_key(root):
    if root.right:
        find_max_key(root.right)
    else:
        return root.right
    





"""
Создайте функцию longest_increasing_subsequence, которая находит длину наибольшей 
возрастающей подпоследовательности в массиве чисел.

Возрастающая подпоследовательность — это последовательность чисел, где каждое следующее 
число больше предыдущего, не обязательно подряд. Например, в массиве [10, 9, 2, 5, 3, 7, 101, 18] 
наибольшими возрастающими подпоследовательностями будут [2, 3, 7, 101] или [2, 5, 7, 18], их длина 
равна 4.

Функция longest_increasing_subsequence принимает на вход список целых чисел. В качестве ответа 
функция должна вернуть длину наибольшей возрастающей подпоследовательности. Используйте 
динамическое программирование для решения задачи.
"""

def longest_increasing_subsequence(array):
    l1 = []
    l2 = []
    for i in range(len(array)):
        el = array[i]
        l1.append(el)
        for j in range(i, len(array)):
            if el < array[j]:
                l1.append(array[j])
                el = array[j]
        l2.append(l1)
        l1 = []

    return max([len(x) for x in l2])










